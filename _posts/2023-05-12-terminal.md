---
layout: post
title:  Terminal
date:   2023-05-12 13:43:00
description: Command cheatsheet
tags: notes code
categories: note-posts
---
#### Useful commands

<a href="https://linuxize.com/post/chmod-recursive/">Change permisson</a>:
{% highlight bash %}
# Make the script files executable
chmod a+x scripts/*.sh

# recursively option -R or --recursive
chmod -R 755 /path/to/directory

# To change all the directories to 755 (drwxr-xr-x):
find /path/to/directory -type d -exec chmod 755 {} \;
# To change all the files to 644 (-rw-r--r--):
find /path/to/directory -type f -exec chmod 644 {} \;

# Use the xargs command to pass multiple entries at once
sudo find /path/to/directory -type d -print0 | xargs -0 sudo chmod 755
sudo find /path/to/directory -type f -print0 | xargs -0 sudo chmod 644
{% endhighlight %}

`chmod 755 {}` specifies the command that will be executed by find for each directory

`chmod 644 {}` specifies the command that will be executed by find for each file

`{}` is replaced by the path

`;` the semicolon tells find that this is the end of the command it's supposed to execute

`\;` the semicolon is escaped, otherwise it would be interpreted by the shell instead of find


<a href="https://www.howtogeek.com/444596/how-to-change-the-default-shell-to-bash-in-macos-catalina/">Change default shell on macOS</a>:
{% highlight bash %}
cat /etc/shells # List the included shells on the system
chsh -s /bin/bash # Change default terminal to bash
chsh -s /bin/zsh # Change default terminal to zsh
{% endhighlight %}

<a href="https://linuxize.com/post/how-get-size-of-file-directory-linux/">Query the size (disk usage) of a directory</a>:
{% highlight bash %}
du -sh [--apparent-size] <dir> # the total (-s) size of the directory in (-h) human readable format
du -h --max-depth=1 <dir> # disk usage of the first-level subdirectories
sudo du -h <dir> | sort -rh | head -5 # print the 5 largest directories within the dir directory
{% endhighlight %}

```bash
df -h
```

<a href="#">Zip</a> and <a href="https://linuxize.com/post/how-to-extract-unzip-tar-gz-file">unzip</a>:
```bash
# List the content
tar -tf archive.tar.gz

# Extract the content
tar -xvf archive.tar.gz [-C /path/of/destination]
# option -x: extraction
#        -v: verbose

# Extract certain files or diretories
tar -xf archive.tar.gz /path/to/file1 /path/to/file2
tar -xf archive.tar.gz dir1 dir2

# Extract files of certian pattern
tar -xf archive.tar.gz --wildcards '*.jpg'
```



<a href="#">Pattern search</a>:
{% highlight bash %}
grep -rnw '/path/to/somewhere/' -e "pattern"
grep --include=\*.{c,h} -rnw '/path/to/somewhere/' -e "pattern"
grep --exclude=\*.o -rnw '/path/to/somewhere/' -e "pattern"
grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/search/' -e "pattern"
# output the line number only
grep -n '/path/to/somefile' -e "pattern" | cut -f1 -d:
# output the two words separated by the delimiter :
grep -n '/path/to/somefile' -e "pattern" | cut -f1,2 -d:
# loop over the returned result
for i in $(grep -n '/path/to/somefile' -e "pattern" | cut -f1 -d:); do 
    echo "$i"
done
# return only the first result
grep -n '/path/to/somefile' -e "pattern" | head -1
{% endhighlight %}

| Options     | Description |
| ----------- | ----------- |
| -r or -R  | recursive |
| -n        | line number |
| -w        | match the whole word |
| -l        | output only the file name of matching files |
| -e        | target pattern |



##### File editing

<a href="https://www.cyberciti.biz/faq/how-to-use-sed-to-find-and-replace-text-in-files-in-linux-unix-shell/">Sed command for replacing text or data</a> and <a href="https://stackoverflow.com/questions/11145270/how-to-replace-an-entire-line-in-a-text-file-by-line-number"> entire line replacement </a>

```bash
find="foo"
replace="bar"

# find $find and replace with $replace using sed 
# ending "/g" means globally replace all occurences
sed -i 's/$find/$replace/g' input.txt
# editing result saved to a new file
sed 's/$find/$replace/g' input.txt > output.txt

# ending "I" means case insensitive search
sed -i 's/word1/word2/gI' input

# you can change the delimiter to keep syntax simple
sed -i 's+word1+word2+g' input
sed -i 's_word1_word2_g' input

# only find word1 and replace it with word2 if line has a specific string such as FOO
sed -i -e '/FOO/s/word1/word2/' input.txt

# replace entire line 7 by line number
sed -i -e '7s/.*/line_replacement/' input.txt
# sed uses symbol $ as the address of the last line
sed -i -e '$s/.*/line_replacement/' input.txt

# insert a new line at line 3
sed -i "3inew line content" input.txt
# insert a new line at the line of the first matched pattern
sed -i "$(grep -n '<input-filepath>' -e 'pattern' | head -1 | cut -f1 -d:)inew line content" input.txt
```


Correct our md file:
```bash
# correct our md file
sed -i 's/% highlight terminal %}/% highlight bash %}/' "*.md"
```


##### File management

<a href="https://www.plesk.com/blog/various/find-files-in-linux-via-command-line/">How To Find a File In Linux From the Command Line</a>

Search for a file

```bash
# find the files with the name_pattern in all the folders below your directory
find /your/directory -iname <name_pattern> # *.jpg
```

See more options from the <a href="https://alvinalexander.com/blog/post/linux-unix/case-insensitive-file-searching-unix-linux-mac-osx">post</a>.

##### Data management
Copy the content of folder:
{% highlight bash %}
# "-a" reserves file attributes, "-r" for recursive copy
cp -ar /source/. /dest/
{% endhighlight %}

##### Network related
<a href="https://stackoverflow.com/questions/12397175/how-do-i-close-an-open-port-from-the-terminal-on-the-mac">Close an open port</a>
<a href="https://www.cyberciti.biz/faq/unix-linux-check-if-port-is-in-use-command/">How to check if port is in use on Linux or Unix</a>

{% highlight bash %}
# List the user processes of the port
sudo lsof -i -P -n | grep LISTEN
sudo lsof -i :<port-number>

sudo netstat -tulpn | grep LISTEN
sudo ss -tulpn | grep LISTEN
sudo nmap -sTU -O IP-address-Here
# Kill the process that occopying the port with its PID
sudo kill -9 <PID-occupying-the-port>
{% endhighlight %}

Curl does not follow HTTP redirections by default, you need to tell curl to do so using the `-L/--location` option:
{% highlight bash %}
# Download file using curl
curl -L http://some.url --output some.file
{% endhighlight %}


#### Command cheatsheet
##### SHORTCUTS

| Key/Command | Description |
| ----------- | ----------- |
| Ctrl + A   | Go to the beginning of the line you are currently typing on.  This also works for most text input fields system wide.  Netbeans being one exception |
| Ctrl + E   | Go to the end of the line you are currently typing on.  This also works for most text input fields system wide.  Netbeans being one exception |
| Ctrl + L   | Clears the Screen |
| Cmd + K    | Clears the Screen |
| Ctrl + U   | Cut everything backwards to beginning of line |
| Ctrl + K   | Cut everything forward to end of line |
| Ctrl + W   | Cut one word backwards using white space as delimiter |
| Ctrl + Y   | Paste whatever was cut by the last cut command |
| Ctrl + H   | Same as backspace |
| Ctrl + C   | Kill whatever you are running.  Also clears everything on current line |
| Ctrl + D   | Exit the current shell when no process is running, or send EOF to a the running process |
| Ctrl + Z   | Puts whatever you are running into a suspended background process. fg restores it |
| Ctrl + _   | Undo the last command. (Underscore.  So it's actually Ctrl + Shift + minus) |
| Ctrl + T   | Swap the last two characters before the cursor |
| Ctrl + F   | Move cursor one character forward |
| Ctrl + B   | Move cursor one character backward |
| Option + →  | Move cursor one word forward |
| Option + ←  | Move cursor one word backward |
| Esc + T  | Swap the last two words before the cursor |
| Esc + Backspace | Cut one word backwards using none alphabetic characters as delimiters |
| Tab  | Auto-complete files and folder names |

##### CORE COMMANDS

| Key/Command | Description |
| ----------- | ----------- |
| cd [folder] | Change directory e.g. `cd Documents` |
| cd |  Home directory |
| cd ~ |  Home directory |
| cd /  | Root of drive |
| cd -  | Previous directory |
| ls | Short listing |
| ls -l | Long listing |
| ls -a | Listing incl. hidden files |
| ls -lh| Long listing with Human readable file sizes |
| ls -R | Entire content of folder recursively |
| sudo [command] | Run command with the security privileges of the superuser (Super User DO) |
| open [file] | Opens a file ( as if you double clicked it ) |
| top | Displays active processes. Press q to quit |
| nano [file] | Opens the file using the nano editor |
| vim [file] | Opens the file using the vim editor |
| clear |  Clears the screen |
| reset |  Resets the terminal display |

##### CHAINING COMMANDS

| Key/Command | Description |
| ----------- | ----------- |
| [command-a]; [command-b] | Run command A and then B, regardless of success of A |
| [command-a] && [command-b] | Run command B if A succeeded |
| [command-a] \|\| [command-b] | Run command B if A failed |
| [command-a] & | Run command A in background |


##### PIPING COMMANDS

| Key/Command | Description |
| ----------- | ----------- |
| [command-a] \| [command-b] | Run command A and then pass the result to command B e.g ps auxwww \| grep google |


##### COMMAND HISTORY

| Key/Command | Description |
| ----------- | ----------- |
| history n |  Shows the stuff typed – add a number to limit the last n items |
| Ctrl + r  | Interactively search through previously typed commands |
| ![value] |  Execute the last command typed that starts with ‘value’ |
| ![value]:p |  Print to the console the last command typed that starts with ‘value’ |
| !! |  Execute the last command typed |
| !!:p |  Print to the console the last command typed |

##### FILE MANAGEMENT

| Key/Command | Description |
| ----------- | ----------- |
| touch [file] |   Create a new file |
| pwd | Full path to working directory |
| . |  Current folder, e.g. `ls .` |
| .. | Parent/enclosing directory, e.g. `ls ..` |
| ls -l .. | Long listing of parent directory |
| cd ../../ | Move 2 levels up |
| cat | Concatenate to screen |
| rm [file] |  Remove a file, e.g. `rm data.tmp` |
| rm -i [file] | Remove with confirmation |
| rm -r [dir] | Remove a directory and contents |
| rm -f [file] | Force removal without confirmation |
| cp [file] [newfile] | Copy file to file |
| cp [file] [dir] | Copy file to directory |
| mv -f [file] [new filename] |  Move/Rename, force overwrite with -f. E.g. `mv file1.ad /tmp` |
| pbcopy < [file] | Copies file contents to clipboard |
| pbpaste | Paste clipboard contents |
| pbpaste > [file] | Paste clipboard contents into file, `pbpaste > paste-test.txt` |

##### DIRECTORY MANAGEMENT

| Key/Command | Description |
| ----------- | ----------- |
| mkdir [dir] | Create new directory |
| mkdir -p [dir]/[dir] |  Create nested directories |
| rmdir [dir] | Remove directory ( only operates on empty directories ) |
| rm -R [dir] | Remove directory and contents |
| less [file]|  Output file content delivered in screensize chunks |
| [command] > [file] |  Push output to file, keep in mind it will get overwritten |
| [command] >> [file] | Append output to existing file |
| [command] < [file] |  Tell command to read content from a file |

##### SEARCH

| Key/Command | Description |
| ----------- | ----------- |
| find [dir] -name [search_pattern] | Search for files, e.g. `find /Users -name "file.txt"` |
| grep [search_pattern] [file] | Search for all lines that contain the pattern, e.g. `grep "Tom" file.txt` |
| grep -r [search_pattern] [dir] | Recursively search in all files in specified directory for all lines that contain the pattern |
| grep -v [search_pattern] [file] | Search for all lines that do NOT contain the pattern |
| grep -i [search_pattern] [file] | Search for all lines that contain the case-insensitive pattern |
| mdfind [search_pattern] | Spotlight search for files (names, content, other metadata), e.g. `mdfind skateboard` |
| mdfind -onlyin [dir] -name [pattern] | Spotlight search for files named like pattern in the given directory |

##### HELP

| Key/Command | Description |
| ----------- | ----------- |
| [command] -h |  Offers help |
| [command] --help | Offers help |
| info [command] | Offers help |
| man [command] |  Show the help manual for [command] |
| whatis [command] | Gives a one-line description of [command] |
| apropos [search-pattern] | Searches for command with keywords in description |

##### GIT

For Git related commmands, check this [git-basics-cheatsheet](https://github.com/0nn0/git-basics-cheatsheet)



